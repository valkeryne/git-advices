# Изучение Git
Добро пожаловать! <br>
В данной инструкции описаны основные команды для Git с комментариями по их использованию. <br>
Версия: 1.1 от 29.12.2025

----
### Настройка и установка 
Для того, чтобы проверить наличие Git на персональном компьютере с Windows, необходимо выполнить следующую команду:
```
$ git version
```
Пользователю будет выведена версия Git.



Указываем данные пользователя для Git и проверям их.
```
$ git config --global user.name "User Name" 
# свое имя латиницей в кавычках

$ git config --global user.email username@email.ru
# свой настоящий e-mail 
```

```
$ cat ~/.gitconfig  
# выводит указанное имя и почту
```

В ответе будет следующее сообщение: <br>
user.name=User Name <br>
user.email=username[собака]email.ru 


```
$ git config --list 
# показывает все системные настройки из системных, глобальных, etc

```

----
### Создание репозитория
Для начала инициализируем папку на локальном компьютере при помощи команды **git init**.
В командной строке переходим в нужную папку при помощи **cd**.
```
$ git init 
# инициализировали новый локальный репозиторий и папку по указанному адресу

```
```
$ git status
# проверили статус созданного репозитория

```


Если нужно удалить в определенной папке Git-репозиторий, выполняем следующую команду, находясь в требуемой папке:
```
$ rm -rf .git
# удалили подпапку .git

```
* ключ -r (от англ. recursive — «рекурсивно») позволяет удалять папки вместе с их содержимым,
* ключ -f (от англ. force — «заставить») позволяет удалить принудительно без лишних всплывающих окон.


**Важно! Если удалить _.git_, то вся история проекта будет стёрта без возможности восстановления — останется только последняя версия файлов.**


В папке .git находится файл HEAD <br>
Внутри HEAD — ссылка на служебный файл: refs/heads/master (или refs/heads/main в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего коммита. Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD — Git поймёт, что вы имели в виду последний коммит.

```
$ cd .git/
# переход в скрытую папку Git


$ cat HEAD
# показать содержимое файла ref: refs/heads/master
```

----
### Добавление файлов в репозиторий
Для начала создадим локально первый файл при помощи команды **touch**, а затем откроем его любым текстовым редактором и заполним информацией, чтобы файл был не пустой.

Для редактирования разметки файла README.md можно пользоваться [шпаргалкой по Markdown](https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c "Шпаргалка по Markdown") 

```
touch README.md
# создаем файл README.md для проекта 


git status
# проверяем, что файл появился в папке, как untracked file
```

Для подготовки файла к отслеживанию состояния изменений выполняем команду **git add**. Если нужно добавить все файлы, используем флаг **--all**

```
$ git add README.md
# подготовить к отслеживанию данный файл

$ git add --all 
# подготовили к сохранению все файлы в репозитории

$ git add . 
# добавить всю текущую папку
```

----
### Выполнение коммита
Используем команду, где в **-m** сообщении указываем кратко, какие изменения были.

```
$ git commit -m "Создан файл Readme.md"

```

----
### Просмотр истории коммитов
```
$ git log

```
>Пример:
>
>$ git log
>commit 91ca21fa86a48748226f69905f44f16c810ebce6 (HEAD -> master, origin/master)
>Author: User Name <username[собака]email.ru>
>Date:   Mon Dec 29 11:11:35 2025 +0300
>
>    Создан файл Readme.md


----
### Отправить изменения на удалённый репозиторий

```
$ git push -u origin master
# отправляем в первый раз изменения на удаленный репозиторий, при ошибке заменить master на main 


$ git push
# пользуемся в дальнейшем при работе с удалённым репозиторием 

``` 

----
### Получить сокращённый лог 
```
$ git log --online

```
Сокращённый лог полезен, если в репозитории уже много коммитов — например, сотни или тысячи. В этом случае можно быстро найти нужный по описанию.
Сокращённый хеш (то есть первые несколько символов полного) можно использовать точно так же, как и полный. Для этого команда **git log --oneline** автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь.

----
###  Хеширование коммитов
Git хеширует (преобразует) информацию о коммите с помощью алгоритма SHA-1 (от англ. Secure Hash Algorithm — «безопасный алгоритм хеширования») и получает для каждого коммита свой уникальный хеш — результат хеширования.


* Git преобразует информацию о коммитах с помощью алгоритма SHA-1 и для каждого из них рассчитывает уникальный идентификатор — хеш.
* Хеш — основной идентификатор коммита и позволяет узнать его автора, дату и содержимое закоммиченных файлов.
* Все хеши, а также таблицу соответствий хеш → информация о коммите Git хранит в папке .git.

----
### Как исправить последний коммит (HEAD)

Дополните последний коммит забытым файлом common.css с помощью опции --amend.

```
$ git add common.css
# добавили файл common.css в список на коммит как обычно

# но вместо команды commit -m '...'
# будет:
$ git commit --amend --no-edit

$ git log --oneline
8340eb2 Добавить главную страницу
# коммит в истории всё ещё один (но у него новый хеш) 
```

Изменить сообщение коммита — *git commit --amend -m "Новое сообщение"*
Может быть и так, что добавлять новые файлы в коммит не нужно, зато понадобилось изменить сообщение.
Допустим, хочется заменить сообщение Добавить главную страницу на Добавить главную страницу и стили. Сделать это можно через *commit --amend* с флагом *-m*.

```
$ git commit --amend -m "Добавить главную страницу и стили"
$ git log --oneline
a31fa24 Добавить главную страницу и стили 
```

Хеш коммита снова поменялся, потому что изменились сообщение и время коммита. При этом файлы в коммите остались те же: main.html и common.css.


----
### Откатываем назад все изменения

*Выполнить unstage изменений — git restore --staged <file>*
Допустим, вы создали или изменили какой-то файл и добавили его в список «на коммит» (staging area) с помощью git add, но потом передумали включать его туда. Убрать файл из staging поможет команда git restore --staged <file> (от англ. restore — «восстановить»).

```
$ touch example.txt # создали ненужный файл
$ git add example.txt # добавили его в staged

$ git status # проверили статус
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   example.txt

$ git restore --staged example.txt
$ git status # проверили статус

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        example.txt

no changes added to commit (use "git add" and/or "git commit -a")
# файл example.txt из staged вернулся обратно в untracked 
```

Чтобы «сбросить» все файлы из staged обратно в untracked/modified, можно воспользоваться командой git restore --staged .: она сбросит всю текущую папку (.).

Иногда нужно «откатить» то, что уже было закоммичено, то есть вернуть состояние репозитория к более раннему. Для этого используют команду git reset --hard <commit hash> (от англ. reset  — «сброс», «обнуление» и hard — «суровый»).

```
$ git log --oneline # хеш можно найти в истории
7b972f5 (HEAD -> master) style: добавить комментарии, расставить отступы
b576d89 feat: добавить массив Expenses и цикл для добавления трат # вот сюда и вернёмся
4b58962 refactor: разделить analyzeExpenses() на countSum() и saveExpenses()

$ git reset --hard b576d89
# теперь мы на этом коммите
HEAD is now at b576d89 feat: добавить массив Expenses и цикл для добавления трат 
```

«Откатить» изменения, которые не попали ни в staging, ни в коммит, — git restore <file>
Может быть так, что вы случайно изменили файл, который не планировали. Теперь он отображается в Changes not staged for commit (modified). Чтобы вернуть всё «как было», можно выполнить команду git restore <file>.

```
# случайно изменили файл example.txt
$ git status
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
          modified:   example.txt

$ git restore example.txt
$ git status
On branch main
nothing to commit, working tree clean 
```

Изменения в файле «откатятся» до последней версии, которая была сохранена через git commit или git add.


Команда git diff сравнит последнюю закоммиченную версию файла с той, что находится в состоянии modified.
Команда git diff --staged покажет изменения в staged-файлах относительно последних закоммиченных версий.

----
### Игнорирование файлов


Правила из .gitignore применяются только к новым (untracked) файлам. Если файл уже попал в staging area или в коммит, то правила на него не распространяются.


Допустим, нужно, чтобы Git игнорировал все файлы .DS_Store. Для этого достаточно добавить в .gitignore строку с названием файла.
```
# для macOS
.DS_Store
```

Символ звёздочки (*) соответствует любой строке, включая пустую. Если такой символ используется в шаблоне в .gitignore, значит, файл будет проигнорирован вне зависимости от того, что будет на месте звёздочки.
```
# игнорировать все файлы, которые заканчиваются на .jpeg
*.jpeg

# игнорировать все файлы "tmp" во всех подпапках папки docs
docs/*/tmp 
```


----
Продолжение следует...